"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = separateStyles;

var _object = _interopRequireDefault(require("object.assign"));

var _has = _interopRequireDefault(require("has"));

// This function takes the array of styles and separates them into styles that
// are handled by Aphrodite and inline styles.
function separateStyles(stylesArray) {
  var aphroditeStyles = []; // Since determining if an Object is empty requires collecting all of its
  // keys, and we want the best performance in this code because we are in the
  // render path, we are going to do a little bookkeeping ourselves.

  var hasInlineStyles = false;
  var inlineStyles = {}; // This is run on potentially every node in the tree when rendering, where
  // performance is critical. Normally we would prefer using `forEach`, but
  // old-fashioned for loops are faster so that's what we have chosen here.

  for (var i = 0; i < stylesArray.length; i += 1) {
    var style = stylesArray[i]; // If this  style is falsey, we just want to disregard it. This allows for
    // syntax like:
    //
    //   css(isFoo && styles.foo)

    if (style) {
      if ((0, _has["default"])(style, '_name') && (0, _has["default"])(style, '_definition')) {
        aphroditeStyles.push(style);
      } else {
        (0, _object["default"])(inlineStyles, style);
        hasInlineStyles = true;
      }
    }
  }

  return {
    aphroditeStyles: aphroditeStyles,
    hasInlineStyles: hasInlineStyles,
    inlineStyles: inlineStyles
  };
}